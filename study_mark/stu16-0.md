# 无畏并发/并发编程（fearless concurrency）

**并发编程旨在提高系统的并发性，以处理多个同时进行的任务。**
**并行编程则专注于利用硬件的并行性来加速特定任务的执行。在实际应用中，两者经常结合使用，以构建高性能的系统。**


rust对于并发编程时常出现的bug提出了自己的解决方案：并发编程旨在提高系统的并发性，以处理多个同时进行的任务。而并行编程则专注于利用硬件的并行性来加速特定任务的执行。在实际应用中，两者经常结合使用，以构建高性能的系统。减少实际部署后才出现问题的可能性，可以通过轻松重构解决问题不会引入新的bug


rust作为一门底层语言以更少的抽象，提供更多的工具对实问题符合实际情况和需求的方式进行建模。代码实现更加复杂


## 使用线程同时运行代码

---

已执行程序的代码在一个 进程（process）中运行，操作系统则负责管理多个进程。
在程序内部，也可以拥有多个同时运行的独立部分。运行这些独立部分的功能被称为 线程（threads）。

---

多线程运行程序的优势

---
- 将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务。
- 增加复杂性。因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序

---

多线程运行程序的问题


---

- 竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源
- 死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行
- 只会发生在特定情况且难以稳定重现和修复的 bug

---

**运行时(Runtime)**

---

既不同语言中实现环境和调用接口获取计算机资源实现代码正常运行的手段。

不同语言之间的区别在于对资源获取采用高级抽象（运行时更少的代码）便于调用资源但是性能较低，rust等底层语言采用低级抽象（运行时更少的代码）直接调用资源，性能较高但是更多的是开发者的责任。

---
**rust的线程实现模型**

---
- Rust 标准库只提供了 1:1 线程模型实现。
由于 Rust 是较为底层的语言，如果你愿意牺牲性能来换取抽象,以获得对线程运行更精细的控制及更低的上下文切换成本 
- 用也有M:N 线程模型的 crate

---

### 使用spawn创建线程


调用 thread::spawn 函数并传递一个闭包作为参数

code-eg；

```

use std::thread;
use std::time::Duration;
fn main() {
    thread::spawn(|| {
        for i in 1..100 {
    println!("hi number {} from the spawned thread!", i);
    thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
    println!("hi number {} from the main thread!", i);
    thread::sleep(Duration::from_millis(1));
    }
}
```
**主线程结束后，所有线程生命都结束，无论任务有无完成。**
主线程优先于子线程，增加主线程执行的时间可以提高系统切换到子线程的效率。



### 使用 join 等待所有线程结束

---
可以使用join方法，实现线程的顺序执行
改变线程的执行次序
spawn::thread返回值类型是 JoinHandle 。 JoinHandle 是一个拥有所有权的值，当对其调用 join 方法时，它会等待其线程结束

code-eg：

```
//snip
handle.join().unwrap();
```
---

### 线程与 move 闭包

使用move 实现不同线程之间的数据交换，move关键字本身具有获取所有权到闭包中的作用

code-eg：

```
use std::{env::var, thread};

fn main() {
    let x = vec![1, 2, 3, 4, 5];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", x);
     });

    //drop(x);
    handle.join().unwrap();
}

```
使用move加上所有权规则可以避免数据竞争
减少多线程编程中出现的bug，以防在实际部署时出现bug

## 使用消息传递在线程间传送数据(message passing)

在rust中采用类似于上下游河流（通道）方式实现消息传递。消息发送者（transmitter）位于上游 ，发送消息，下游有接收者（receiver）接收, 接收者和发送者任一方被废弃就认为通道被关闭（closed）


使用mpsc 是 多个生产者，单个消费者（multipleproducer, single consumer）的缩写。简而言之，Rust 标准库实现通道的方式意味着一个通道可以有多个产生值的 发送（sending）端，但只能有一个消费这些值的 接收（receiving）端
code-eg：

```
use std::sync::mpsc;
fn main() {
    let (tx, rx) = mpsc::channel();
}
```

创建一个在新线程发送字符

```
use std::thread;
use std::sync::mpsc;
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });
}

```

创建一个线程发送信息并在主线程中接收消息


code-eg：

```
use std::thread;
use std::sync::mpsc;
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got：{}"， received);
}
```
只要子线程冰雹使用的变量都会发生所有权的转移

### 通道与所有权转移

在子线程中tx发送的变量其所有权会发生转移到接收者所在的线程


### 发送多个值并观察接收者的等待

说明代码的不同部分在不同线程中并发执行

code-eg：

```


use std::thread;
use std::sync::mpsc;
use std::time::Duration;
fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
        ];
        for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
        }
    });
    for received in rx {
        println!("Got: {}", received);
    }
}
```
留足时间便于操作系统在线程间切换

### 通过克隆发送者来创建多个生产者

可以通过接口克隆一个线程tx产生多个tx


code-eg：

```

// --snip--
    let (tx, rx) = mpsc::channel();
    let tx1 = tx.clone();
    thread::spawn(move || {
    let vals = vec![
        String::from("hi"),
        String::from("from"),
        String::from("the"),
        String::from("thread"),
    ];
    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});
    thread::spawn(move || {
    let vals = vec![
        String::from("more"),
        String::from("messages"),
        String::from("for"),
        String::from("you"),
    ];
    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});
for received in rx {
    println!("Got: {}", received);
} 
// --snip--
```
**在线程sleep不同是并发执行的的代码可能不同。没有干扰每个线程的执行速度可能也不同，哪怕代码相同**

## 共享状态并发











