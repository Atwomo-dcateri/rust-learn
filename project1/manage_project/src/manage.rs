//title:使用包、Crate和模块管理不断增长的项目


//伴随着项目的增长，你可以通过将代码分 解为多个模块和多个文件来组织代码

//一个包可以包含多个二进制 crate 项和一个可选的 crate 库。

//伴随着包的增长，你可以将包中的部分代码提取出来，做成独立的 
//crate，这些crate则作为外部依赖项

//crate除了对功能进行分组以外，封装实现细节可以使你更高级地重用代码

//编写代码时可以定义哪些部分是其他代码可以使用的公共部分，以及哪些部分是你有权更改实现细节的私有部分
//是减少项目数量的一种方法

//对于作用域每个代码所在的嵌套上下文有一组定义为 “in scope” 的 名称。当阅读、编写和编译代码时，程序员和编译器需要知道特定位置的特定名称是否引用了变量、
//函数、结构体、枚举、模块、常量或者其他有意义的项
//在作用域中还是作用域内修改名称


//模块系统（the module system）

//构成

/*
包（Packages）： Cargo 的一个功能，它允许你构建、测试和分享 crate。 
Crates ：一个模块的树形结构，它形成了库或二进制项目。 
模块（Modules）和 use： 允许你控制作用域和路径的私有性。
路径（path）：一个命名例如结构体、函数或模块等项的方式
*/


//第一部分：

//包和crate

//1：crate

//1.1crate 是一个二进制项或者库

//crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块(所有模块都要通过这个模块才能调用)（我们将在 “定义模块来控制作用域与私
//有性” 一节深入解读）。


//2包（package） 是提供一系列功能的一个或者多个 crate。（多个公共的API）
//2.1一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate

//2.2包内容组成原则：

//一个包中至多只能包含一个库 crate(library crate)//gpio库内只含有与gpio有关的函数，而函数的数量是没有限制的
//包中可以包含任意多个二进制 crate(binary crate)
//包中至少包含一个 crate，无论是库的还是二进制的

//3通过创建一个cargo包说明以上包和crate

//3.1Cargo 会给我们的包创建一个 Cargo.toml 文件

//3.2.1src/main.rs 就是一个与包同名的二进 制 crate 的 crate 根

//3.2.2Cargo 遵循的一个约定：src/main.rs 就是一个与包同名的二进 制 crate 的 crate 根
//Cargo 知道如果包目录中包含 src/lib.rs，则包带有与其同名的库 crate，且 src/lib.rs 是 crate 根

//crate 根文件将由 Cargo 传递给 rustc 来实际构建库或者二进制项目

//如果一个包同时含有 src/main.rs 和 src/lib.rs，则它有两个 crate：
//一个库和一个二进制项， 且名字都与包相同

//一个包可以拥有多个二进制 crate：每个 src/bin 下的文件都会被编译成一个独立的二进制 crate

//一个 crate 会将一个作用域内的相关功能分组到一起，使得该功能可以很方便地在多个项目之间共享

//crate可以将一个作用域中的功能进行分组
//每个二进制crate都是由多个函数构成，他们之间存在关联，作用域存在共享


// crate 的功能保持在其自身的作用域中，可以知晓一些特定的功能是在我们的 crate 中定义的 
// 还是在 rand crate 中定义的，这可以防止潜在的冲突

//对于同名的类型，方法不会不会产生冲突，


//定义模块来控制作用域的私有性


//第一部分模块（module）

//模块 让我们可以将一个 crate（类似于一个源文件） 中的代码进行分组，以提高可读性与重用性


//模块还可以控制项的 私 有性，即项是可以被外部代码使用的（public），还是作为一个内部实现的内容，不能被外部代码使
//用（private）
